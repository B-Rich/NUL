#+TITLE: NUL: NOVA Userland
#+AUTHOR: Julian Stecklina
#+LANGUAGE: en
#+TODO: TODO INPROGRESS | CLOSED CANCELED
#+STARTUP: showall hidestars

Thank you for obtaining your personal NOVA userland (NUL) source
tree. You will not be disappointed.

* Org-Mode HOWTO						   :noexport:

  This file uses Org-Mode, which ships with a nice manual that you can
  find via the Info browser (C-h i). I recommend reading the 5min
  tutorial, if you are unfamiliar with Org-Mode:
  http://orgmode.org/worg/org-tutorials/

  Some hints:
  C-c C-t: Cycle through TODO states.
  C-c C-z: Take a note.
  TAB on section header: Cycle through visibility states.
  Shift-TAB: Toggle overview.
  C-c C-e l: Export as LaTeX. :-D

* Introduction

  This is the development version of NUL, the NOVA UserLand.  It
  complements the NOVA microhypervisor with a couple of applications,
  mainly a virtual machine monitor and a hardware resource
  multiplexer.

  The code is still experimental and far from feature complete.  Use
  it on your own risk.  If it breaks, you get to keep both pieces.  If
  you have feedback, please sent it to =bk@vmmon.org=.

* Prerequisites

  - *Binutils* 2.19 or later
  - *GCC* 4.2 or later
  - *SCons[fn:1]* 1.2.0 or later
  - *Python* 2.6 or later
  - *Git* 1.6 or later

* Where To Get It

  The latest public version is available by cloning our Git
  repository. You have to be member of the =nul-hackers= group to
  commit.

  =git clone ssh://os.inf.tu-dresden.de/srv/git/repos/nul.git=

* Development

  This section is aimed at the prospective NUL hacker. Its purpose is
  to boot your knowledge about nul to a point where you can start
  hacking on it.

** Directory Layout

   The NUL tree consists of several applications and libraries, which
   are loosely grouped by topic into repositories. Each subdirectory
   of the top-level directory is a repository.

*** /nova/

   The kernel bindings and a very small example roottask live in this
   repository. =lib/nova/include= contains the relevant header files.
   
**** TODO Clean up handling of MTDs.
     The current solution makes it very easy to shoot yourself in the foot.

*** TODO Describe /vancouver/


** Building

  To build NUL you need a build directory. Luckily, there is already a
  preconfigured one in /build/. We use a minimal SCons-based build
  system that mostly does what we want. So to build the default
  configuration just cd into build and type =scons=. Binaries will be
  installed in build/bin by default.

  To use a customized build configuration, copy the default build
  repository and adapt its SConstruct file.

  There are some variables that can be passed to SCons in order to
  control the build process.

  |------------------+-----------------------------|
  | *Argument*       | *Description*               |
  |------------------+-----------------------------|
  | target_cc=mycc   | Compile C code with mycc.   |
  |------------------+-----------------------------|
  | target_cxx=myc++ | Compile C++ code with myc++ |
  |------------------+-----------------------------|

  To compile nul with an old version of GCC, type:
  =scons target_cc=gcc-4.2.4 target_cxx=g++-4.2.4=

** TODO Booting 

** Using Git

   We use git to manage our source code. (Un)fortunately, there are
   many ways to use git. Let's summarize some hints and "best
   practices". If you are completely unfamiliar with Git, you should
   read one of the many tutorials first. A good one for the
   Subversion-proficient reader is http://git.or.cz/course/svn.html.

*** User Setup

    It is important to use your real name and a working email address as these are stored in your commits. Set them using:

    - =git config --global user.name yourname=
    - =git config --global user.email you@yourdomain.example.com=

*** Simple Updating and Committing

    If you cloned the repository as shown [[git clone][above]], you can pull the
    latest changes from the central repository by simply typing =git
    pull=. If you have local commits and someone else committed to the
    central repository, this will automatically create a merge between
    your repository head and the head of the central repository.

    =git push= does the reverse and pushes your changes to the central
    server.

*** Rebase

    There are two downsides to the simple approach: Pulling blindly
    might be undesirable in some cases, as it can create a lot of
    conflicts. A second downside is the creation of a non-linear
    history, if you push the created merge commits back to the central
    repository. This is easily avoidable, except for very complex
    patches and merging of long-lived branches.

    A slightly more complex way to update your tree and commit your
    changes is to first inspect the changes your co-workers commited
    and then /rebase/ your changes on top of theirs before you push
    them to the central repository. Rebasing your local changes before
    committing keeps the central history merge-free and linear, which
    is a good thing!

    The workflow would thus be:
    
    - =git remote update= to get the latest changes from the central repository[fn:2]
    - =gitk --all= (for X11 users) or =tig --all= (for those console junkies) to see your local branches as well as the remote branches.
    - =git rebase origin/master= to rebase your local commits on top
      of the central repository's head. If you like to reorder or
      squash your commits[fn:3], you can pass the =-i= flag to rebase.

    At this point, your local branch contains all commits from the
    central repository with your commits on top of them. If you wish
    to commit them, you can now do =git push= to send them to the
    central repository.

** TODO Using the Build System

* Tasks
** TODO Port existing code to C-friendly syscall bindings in nova/
** TODO Organize 3rd-Party Source Code
*** TODO Move vancouver/lib/tinf to some kind of contrib/ directory
    - Note taken on [2009-11-13 Fri 16:12] \\
      rocknshine including tinf should perhaps move to their own
      repo. Something like julian-stuff.
** TODO Fix rocknshine regarding bytes-per-scanline.
 * TODO Implement "jump to page" in rocknshine.
 * TODO Write tool that collects sigma0/vancouver command line arguments.

* Third-Party Software

  NUL reuses currently some code from the following projects:

  - QEMU's ne2k model: http://www.qemu.org/

  See the contrib directories for details.

* Footnotes

[fn:1] We are actively exploring alternatives to write our build system, but SCons fills in quite nicely for now.

[fn:2] This step might be optional. I have to check this.

[fn:3] Git rocks, doesn't it?
