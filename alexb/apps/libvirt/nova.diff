--- libvirt-0.8.8/configure.ac	2011-02-17 04:00:39.000000000 +0100
+++ libvirt-0.8.8-own/configure.ac	2011-03-04 16:57:29.000000000 +0100
@@ -274,6 +274,8 @@
   AC_HELP_STRING([--with-remote], [add remote driver support @<:@default=yes@:>@]),[],[with_remote=yes])
 AC_ARG_WITH([libvirtd],
   AC_HELP_STRING([--with-libvirtd], [add libvirtd support @<:@default=yes@:>@]),[],[with_libvirtd=yes])
+AC_ARG_WITH([nova],
+  AC_HELP_STRING([--with-nova], [add Nova support @<:@default=check@:>@]),[],[with_nova=yes])
 
 dnl
 dnl in case someone want to build static binaries
@@ -443,6 +445,11 @@
 fi
 AM_CONDITIONAL([WITH_TEST], [test "$with_test" = "yes"])
 
+if test "$with_nova" = "yes" ; then
+    AC_DEFINE_UNQUOTED([WITH_NOVA], 1, [whether NOVA driver is enabled])
+fi
+AM_CONDITIONAL([WITH_NOVA], [test "$with_nova" = "yes"])
+
 if test "$with_remote" = "yes" ; then
     AC_DEFINE_UNQUOTED([WITH_REMOTE], 1, [whether Remote driver is enabled])
 fi
@@ -2356,6 +2363,7 @@
 AC_MSG_NOTICE([    PHYP: $with_phyp])
 AC_MSG_NOTICE([     ONE: $with_one])
 AC_MSG_NOTICE([     ESX: $with_esx])
+AC_MSG_NOTICE([    NOVA: $with_nova])
 AC_MSG_NOTICE([    Test: $with_test])
 AC_MSG_NOTICE([  Remote: $with_remote])
 AC_MSG_NOTICE([ Network: $with_network])
--- libvirt-0.8.8/src/Makefile.am	2011-02-10 04:08:11.000000000 +0100
+++ libvirt-0.8.8-own/src/Makefile.am	2011-03-04 16:57:29.000000000 +0100
@@ -244,6 +244,9 @@
 		lxc/lxc_controller.c				\
 		lxc/veth.c lxc/veth.h
 
+NOVA_DRIVER_SOURCES =						\
+		nova/nova_driver.c nova/nova_driver.h
+
 SECURITY_DRIVER_APPARMOR_HELPER_SOURCES =			\
 		security/virt-aa-helper.c
 
@@ -488,6 +491,21 @@
 libvirt_driver_test_la_SOURCES = $(TEST_DRIVER_SOURCES)
 endif
 
+if WITH_NOVA
+if WITH_DRIVER_MODULES
+mod_LTLIBRARIES += libvirt_driver_nova.la
+else
+noinst_LTLIBRARIES += libvirt_driver_nova.la
+libvirt_la_BUILT_LIBADD += libvirt_driver_nova.la
+endif
+libvirt_driver_nova_la_CFLAGS = \
+		-I@top_srcdir@/src/conf $(AM_CFLAGS)
+if WITH_DRIVER_MODULES
+libvirt_driver_nova_la_LDFLAGS = -module -avoid-version $(AM_LDFLAGS)
+endif
+libvirt_driver_nova_la_SOURCES = $(NOVA_DRIVER_SOURCES)
+endif
+
 if WITH_REMOTE
 if WITH_DRIVER_MODULES
 mod_LTLIBRARIES += libvirt_driver_remote.la
@@ -976,6 +994,7 @@
 		$(XENAPI_DRIVER_SOURCES)			\
 		$(ESX_DRIVER_SOURCES)				\
 		$(ESX_DRIVER_EXTRA_DIST)			\
+		$(NOVA_DRIVER_SOURCES)				\
 		$(NETWORK_DRIVER_SOURCES)			\
 		$(INTERFACE_DRIVER_SOURCES)			\
 		$(STORAGE_DRIVER_SOURCES)			\
@@ -1226,6 +1245,10 @@
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/lxc"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/lxc"
 endif
+if WITH_NOVA
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/nova"
+	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/nova"
+endif
 if WITH_UML
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/lib/libvirt/uml"
 	$(MKDIR_P) "$(DESTDIR)$(localstatedir)/run/libvirt/uml"
@@ -1263,6 +1286,10 @@
 	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/lxc" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/lxc" ||:
 endif
+if WITH_NOVA
+	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/nova" ||:
+	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/nova" ||:
+endif
 if WITH_UML
 	rmdir "$(DESTDIR)$(localstatedir)/lib/libvirt/uml" ||:
 	rmdir "$(DESTDIR)$(localstatedir)/run/libvirt/uml" ||:
--- libvirt-0.8.8/src/driver.h	2011-02-09 10:48:30.000000000 +0100
+++ libvirt-0.8.8-own/src/driver.h	2011-03-04 16:57:29.000000000 +0100
@@ -28,7 +28,8 @@
     VIR_DRV_ESX = 10,
     VIR_DRV_PHYP = 11,
     VIR_DRV_XENAPI = 12,
-    VIR_DRV_VMWARE = 13
+    VIR_DRV_VMWARE = 13,
+    VIR_DRV_NOVA = 14
 } virDrvNo;
 
 
--- libvirt-0.8.8/src/libvirt.c	2011-02-16 07:36:53.000000000 +0100
+++ libvirt-0.8.8-own/src/libvirt.c	2011-03-04 16:57:29.000000000 +0100
@@ -69,6 +69,9 @@
 # ifdef WITH_XENAPI
 #  include "xenapi/xenapi_driver.h"
 # endif
+# ifdef WITH_NOVA
+#  include "nova/nova_driver.h"
+# endif
 #endif
 
 #define VIR_FROM_THIS VIR_FROM_NONE
@@ -398,6 +401,9 @@
 # ifdef WITH_XENAPI
     virDriverLoadModule("xenapi");
 # endif
+# ifdef WITH_NOVA
+    virDriverLoadModule("nova");
+#endif
 # ifdef WITH_REMOTE
     virDriverLoadModule("remote");
 # endif
@@ -426,6 +432,9 @@
 # ifdef WITH_XENAPI
     if (xenapiRegister() == -1) return -1;
 # endif
+# ifdef WITH_NOVA
+    if (novaRegister () == -1) return -1;
+# endif
 # ifdef WITH_REMOTE
     if (remoteRegister () == -1) return -1;
 # endif
@@ -940,6 +949,10 @@
         if (STRCASEEQ(type, "ESX"))
             *typeVer = LIBVIR_VERSION_NUMBER;
 # endif
+# if WITH_NOVA
+        if (STRCASEEQ(type, "NOVA"))
+            *typeVer = LIBVIR_VERSION_NUMBER;
+# endif
 # if WITH_XENAPI
         if (STRCASEEQ(type, "XenAPI"))
             *typeVer = LIBVIR_VERSION_NUMBER;
--- libvirt-0.8.8/examples/domain-events/events-c/event-test.c	2010-05-14 15:40:42.000000000 +0200
+++ libvirt-0.8.8-own/examples/domain-events/events-c/event-test.c	2011-06-20 15:23:43.000000000 +0200
@@ -166,9 +166,9 @@
                                   int detail,
                                   void *opaque ATTRIBUTE_UNUSED)
 {
-    printf("%s EVENT: Domain %s(%d) %s %s\n", __func__, virDomainGetName(dom),
+    printf("%s EVENT: Domain %s(%d) %s %s detail=%x\n", __func__, virDomainGetName(dom),
            virDomainGetID(dom), eventToString(event),
-           eventDetailToString(event, detail));
+           eventDetailToString(event, detail), detail);
     return 0;
 }
 
@@ -444,7 +444,7 @@
                                                     VIR_DOMAIN_EVENT_CALLBACK(myDomainEventGraphicsCallback),
                                                     strdup("callback graphics"), myFreeFunc);
 
-    if ((callback1ret != -1) &&
+    if (//(callback1ret != -1) &&
         (callback2ret != -1) &&
         (callback3ret != -1) &&
         (callback4ret != -1) &&
diff -urN libvirt-0.8.8/src/nova/nova_conf.h libvirt-0.8.8-own/src/nova/nova_conf.h
--- libvirt-0.8.8/src/nova/nova_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.8.8-own/src/nova/nova_conf.h	2011-06-17 10:49:20.000000000 +0200
@@ -0,0 +1,13 @@
+#ifndef __VIR_NOVA_CONF_H__
+# define __VIR_NOVA_CONF_H__
+
+# include "domain_event.h"
+
+struct nova_conn {
+  int sockfd;
+  int eventfd;
+  virDomainEventCallbackListPtr domainEventCallbacks;
+//  virDomainEventQueuePtr domainEventQueue;
+};
+
+#endif /* __VIR_NOVA_CONF_H__ */
diff -urN libvirt-0.8.8/src/nova/nova_driver.c libvirt-0.8.8-own/src/nova/nova_driver.c
--- libvirt-0.8.8/src/nova/nova_driver.c	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.8.8-own/src/nova/nova_driver.c	2011-06-21 13:59:32.000000000 +0200
@@ -0,0 +1,525 @@
+#include <sys/socket.h> //socket
+#include <arpa/inet.h> //inet_pton
+
+#include "virterror_internal.h"
+#include "datatypes.h"
+#include "nova_driver.h"
+#include "buf.h"
+#include "util.h"
+#include "uuid.h"
+#include "capabilities.h"
+#include "memory.h"
+#include "network_conf.h"
+#include "interface_conf.h"
+#include "domain_conf.h"
+#include "domain_event.h"
+#include "event.h"
+#include "storage_conf.h"
+#include "node_device_conf.h"
+#include "xml.h"
+#include "threads.h"
+#include "logging.h"
+
+#include "nova_types.h"
+#include "nova_conf.h"
+
+#include <fcntl.h>
+
+static virThreadPtr eventthread;
+static void novaReadEvents(void *data) {
+  virConnectPtr nconn = (virConnectPtr)data;
+  struct nova_conn * conn = (struct nova_conn *)nconn->privateData;
+
+  unsigned char buf[NOVA_PACKET_LEN];
+  int res;
+
+  while(true) {
+    unsigned count = 0;
+    while(count < sizeof(buf)) {
+      res = read(conn->eventfd, buf + count, sizeof(buf) - count);
+      if (res == -1) return;
+      count += res;
+    }
+
+    struct outgoing_packet * in = (struct outgoing_packet *)buf;
+
+    if (in->version != ntohs(0xafff)) { printf("eventthread - version error %x != %x\n", ntohs(in->version), 0xafff); continue;}
+    if (in->opcode != ntohs(NOVA_EVENT)) { printf("eventthread - opcode error %x != %x\n", ntohs(in->opcode), NOVA_EVENT ); continue;}
+
+    virDomainPtr dom = virDomainLookupByUUID(nconn, &in->opspecific);
+    if (!dom) continue;
+
+    uint32_t eventid      = *((uint32_t *)(&in->opspecific + 16));
+    uint32_t extra_len    = *((uint32_t *)(&in->opspecific + 16 + sizeof(uint32_t)));
+    unsigned char * extra = &in->opspecific + 16 + 2 * sizeof(uint32_t);
+    virDomainEventPtr event;
+
+    if (ntohl(eventid) == EVENT_REBOOT)
+      event = virDomainEventRebootNewFromDom(dom);
+    else
+      event = virDomainEventNewFromDom(dom, eventid, ntohl(extra_len) == sizeof(uint32_t) ? *((uint32_t *)extra) : 0);
+
+    if (!event) goto cleanup;
+//    if (virDomainEventQueuePush(conn->domainEventQueue, event) < 0) { virDomainEventFree(event); continue; }
+//    virDomainEventQueueDispatch(conn->domainEventQueue, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+    virDomainEventDispatch(event, conn->domainEventCallbacks, virDomainEventDispatchDefaultFunc, NULL);
+
+    virDomainEventFree(event);
+
+    cleanup:
+    virUnrefDomain(dom);
+  } 
+
+  return; 
+}
+
+static virDrvOpenStatus novaOpen(virConnectPtr conn,
+                    virConnectAuthPtr auth ATTRIBUTE_UNUSED,
+                    int flags ATTRIBUTE_UNUSED)
+{
+    int sockfd = 0, eventfd = 0;
+    struct nova_conn *nconn = 0;
+
+    if (!conn->uri)
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->scheme || STRNEQ(conn->uri->scheme, "nova"))
+        return VIR_DRV_OPEN_DECLINED;
+
+    if (!conn->uri->server || !conn->uri->port || conn->privateData)
+        return VIR_DRV_OPEN_DECLINED;
+
+    struct sockaddr_in addr;
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(conn->uri->port);
+    if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr))
+      return VIR_DRV_OPEN_DECLINED;
+
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sockfd < 0) goto error;
+    if (connect(sockfd, (struct sockaddr *)&addr, sizeof(addr))) goto error;
+
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(conn->uri->port + 1);
+    if (1 != inet_pton(AF_INET, conn->uri->server, &addr.sin_addr))
+      return VIR_DRV_OPEN_DECLINED;
+
+    eventfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (eventfd < 0) goto error;
+    if (connect(eventfd, (struct sockaddr *)&addr, sizeof(addr))) goto error;
+
+    if (VIR_ALLOC(nconn) < 0) goto error;
+    memset(nconn, 0, sizeof(*nconn));
+    if (VIR_ALLOC(nconn->domainEventCallbacks) < 0) goto error;
+//    if (!(nconn->domainEventQueue = virDomainEventQueueNew())) goto error;
+
+    nconn->sockfd  = sockfd;
+    nconn->eventfd = eventfd;
+    conn->privateData = nconn;
+
+    if (VIR_ALLOC(eventthread) < 0) goto error; 
+    if (virThreadCreate(eventthread, false, novaReadEvents, conn)) goto error;
+
+    return VIR_DRV_OPEN_SUCCESS;
+
+    error:
+    if (nconn && nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+    if (nconn) VIR_FREE(nconn);
+    if (eventthread) VIR_FREE(eventthread);
+    if (sockfd) close(sockfd);
+    if (eventfd) close(eventfd);
+
+    return VIR_DRV_OPEN_DECLINED;
+}
+
+static int novaClose(virConnectPtr conn)
+{
+    int res;
+    struct nova_conn *nconn;
+
+    if (!(nconn = conn->privateData)) return -1;
+    
+    res = close(nconn->sockfd);
+    res = close(nconn->eventfd);
+
+    if (nconn->domainEventCallbacks) VIR_FREE(nconn->domainEventCallbacks);
+//    if (nconn->domainEventQueue) virDomainEventQueueFree(nconn->domainEventQueue);
+    if (eventthread) VIR_FREE(eventthread);
+    VIR_FREE(nconn);
+    conn->privateData = 0;
+
+    printf("nova - %s - close connection to ...\n", res ? "failure" : "success");
+    return res;
+}
+
+#define create_nova_request(CONN, NOVAOPCODE, ERRORCODE, CODE) \
+  struct nova_conn *nconn = (CONN)->privateData; \
+  int sockfd = nconn->sockfd; \
+\
+  unsigned char buf[NOVA_PACKET_LEN]; \
+  struct incoming_packet * _out = (struct incoming_packet *)buf; \
+  ssize_t ___res___; \
+\
+  _out->version = htons(0xafff); \
+  _out->opcode  = htons(NOVAOPCODE); \
+\
+  CODE \
+\
+  if (sizeof(buf) != write(sockfd, buf, sizeof(buf))) return ERRORCODE; \
+  unsigned ___count___ = 0; \
+  while(___count___ < sizeof(buf)) { \
+    ___res___ = read(sockfd, buf + ___count___, sizeof(buf) - ___count___); \
+    if (___res___ == -1) return ERRORCODE; \
+    ___count___ += ___res___; \
+  } \
+\
+  struct outgoing_packet * _in = (struct outgoing_packet *)buf; \
+\
+  if (_in->version != ntohs(0xafff)) { printf("version error\n"); return ERRORCODE; } \
+  if (_in->opcode != ntohs(NOVAOPCODE)) { printf("opcode error\n"); return ERRORCODE; } \
+  if (_in->result != NOVA_OP_SUCCEEDED) { printf("result error\n"); return ERRORCODE; }
+
+static int numOfDomains(virConnectPtr conn) {
+
+  create_nova_request(conn, NOVA_NUM_OF_ACTIVE_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+  return res;
+}
+
+static int listDomains (virConnectPtr conn,
+                            int *ids,
+                            int maxids)
+{
+  create_nova_request(conn, NOVA_LIST_ACTIVE_DOMAINS, -1, {});
+
+  unsigned i;
+  uint32_t * _ids  = (uint32_t *)&_in->opspecific;
+  uint32_t _maxids = ntohl(*_ids);
+
+  _ids++;
+
+  uint32_t max = _maxids < maxids ? _maxids : maxids;
+
+  for (i=0; i < max; i++) {
+    *ids = ntohl(*_ids);
+    ids++;
+    _ids++; 
+  }
+
+  return max;
+}
+
+static int numOfDefinedDomains(virConnectPtr conn) {
+  create_nova_request(conn, NOVA_NUM_OF_DEFINED_DOMAINS, -1, {});
+
+  uint32_t * num = (uint32_t *)&_in->opspecific;
+  uint32_t res = ntohl(*num);
+
+  return res;
+}
+
+static virDomainPtr domainLookupByUUID(virConnectPtr conn,
+                                       const unsigned char *uuid)
+{
+  create_nova_request(conn, NOVA_GET_NAME_UUID, NULL, 
+    {
+      memcpy(&_out->opspecific, uuid, VIR_UUID_BUFLEN);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+  char const * name = (char const *)(&_in->opspecific + sizeof(*_op));
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static virDomainPtr domainLookupByID(virConnectPtr conn, int id)
+{
+  create_nova_request(conn, NOVA_GET_NAME_ID, NULL, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(id);
+    });
+
+  buf[NOVA_PACKET_LEN - 1] = 0; //zero terminate for sure
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * name = (char const *)(&_in->opspecific + 16);
+
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = id;
+
+  return res;
+}
+
+static int domainCreate(virDomainPtr domain) {
+  create_nova_request(domain->conn, NOVA_VM_START, -1, {
+    unsigned char _uuid[VIR_UUID_BUFLEN];
+    if (-1 == virUUIDGenerate(_uuid)) return -1;
+
+    char * uuid = (char *)&_out->opspecific;
+    memcpy(uuid, domain->uuid, VIR_UUID_BUFLEN);
+    uuid += VIR_UUID_BUFLEN;
+    memcpy(uuid, _uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * _op = (uint32_t *)&_in->opspecific;
+  int id = ntohl(*_op);
+
+  if (id) {
+    virDomainPtr res = domainLookupByID(domain->conn, id);
+    if (res) res->id = id;
+    else return -1;
+  }
+  return 0;
+}
+
+static int domainIsPersistent(virDomainPtr dom) {
+  if (!dom) return -1;
+
+  if (dom->id == -1) return 1; //XXX fix it - guessing
+  return 0;
+}
+
+static int domainEventRegisterAny(virConnectPtr conn, 
+  virDomainPtr dom, int eventID, virConnectDomainEventGenericCallback cb,
+  void * opaque, virFreeCallback freecb) //XXX currently no registry per event possible, all or nothing for all domains or just for a specific
+{
+  int res;
+
+  create_nova_request(conn, NOVA_ENABLE_EVENT, -1, 
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      if (dom)
+        *out_id = htonl(dom->id);
+      else
+        *out_id = htonl(-1);
+    });
+
+  res = virDomainEventCallbackListAddID(conn,
+                                        nconn->domainEventCallbacks,
+                                        dom, eventID,
+                                        cb, opaque, freecb);
+  return res;
+}
+
+static int domainEventDeregisterAny(virConnectPtr conn, int callbackID)
+{
+  create_nova_request(conn, NOVA_DISABLE_EVENT, -1,
+    {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(-1);
+    });
+ 
+  return virDomainEventCallbackListRemoveID(conn, nconn->domainEventCallbacks, callbackID);
+}
+
+static int listDefinedDomains(virConnectPtr conn, char ** const names, int maxnames)
+{
+  unsigned i;
+  char * out;
+
+  create_nova_request(conn, NOVA_LIST_DEFINED_DOMAINS, -1, {
+      uint32_t * max = (uint32_t *)&_out->opspecific;
+      *max = htonl(maxnames);
+    });
+
+  uint32_t * _num = (uint32_t *)&_in->opspecific;
+  uint32_t    num = ntohl(*_num);
+  char     * name = (char *)(&_in->opspecific + 4);
+
+  for (i=0; i < num; i++) {
+    uint32_t len   = strlen(name) + 1;
+  
+    if (-1 == virAlloc(&out, len)) return -1;
+    memcpy(out, name, len);
+    names[i] = out;
+    name += len;
+  }
+
+  return num;
+}
+
+static virDomainPtr domainLookupByName(virConnectPtr conn, const char * name)
+{
+  create_nova_request(conn, NOVA_GET_NAME, NULL,
+    {
+      if (strlen(name) + 1 > NOVA_PACKET_LEN - (&_out->opspecific - buf)) return NULL;
+      memcpy(&_out->opspecific, name, strlen(name) + 1);
+    });
+
+  unsigned char const * uuid = (unsigned char const *)&_in->opspecific;
+  char const * _name = (char const *)(&_in->opspecific + 16);
+
+  if (memcmp(name, _name, strlen(name) + 1)) return NULL;
+  virDomainPtr res = virGetDomain(conn, name, uuid);
+  if (res) res->id = -1;
+
+  return res;
+}
+
+static int domainDestroy (virDomainPtr domain)
+{
+  if (!domain || domain->id == -1) return -1;
+
+  create_nova_request(domain->conn, NOVA_VM_DESTROY, -1, {
+      uint32_t * out_id = (uint32_t *)&_out->opspecific;
+      *out_id = htonl(domain->id);
+  });
+
+  return 0;
+}
+
+static int domainGetInfo (virDomainPtr domain,
+                          virDomainInfoPtr info)
+{
+  if (!info || !domain) return -1;
+
+  create_nova_request(domain->conn, NOVA_GET_VM_INFO, -1, {
+    memcpy(&_out->opspecific, domain->uuid, VIR_UUID_BUFLEN);
+  });
+
+  uint32_t * memory = (uint32_t *)&_in->opspecific;
+  uint32_t * vcpus  = (uint32_t *)(&_in->opspecific + sizeof(uint32_t));
+  uint64_t * t_cpu  = (uint64_t *)(&_in->opspecific + 2*sizeof(uint32_t));
+
+  if (domain->id == -1)
+    info->state  = VIR_DOMAIN_NOSTATE;
+  else
+    info->state  = VIR_DOMAIN_RUNNING;
+
+  info->maxMem    = ntohl(*memory);  // the maximum memory in KBytes allowed
+  info->memory    = ntohl(*memory);  // the memory in KBytes used by the domain
+  info->nrVirtCpu = ntohl(*vcpus);   // the number of virtual CPUs for the domain
+  info->cpuTime   = be64toh(*t_cpu) * 1000; // get in microseconds - time used in nanoseconds
+
+  return 0;
+}
+
+static virDriver novaDriver = {
+    VIR_DRV_NOVA,
+    "NOVA",
+    novaOpen, /* open */
+    novaClose, /* close */
+    NULL, /* supports_feature */
+    NULL, /* type */
+    NULL, /* version */
+    NULL, /* libvirtVersion (impl. in libvirt.c) */
+    NULL, /* getHostname */
+    NULL, /* getSysinfo */
+    NULL, /* getMaxVcpus */
+    NULL, /* nodeGetInfo */
+    NULL, /* getCapabilities */
+    listDomains, /* listDomains */
+    numOfDomains, /* numOfDomains */
+    NULL, /* domainCreateXML */
+    domainLookupByID, /* domainLookupByID */
+    domainLookupByUUID, /* domainLookupByUUID */
+    domainLookupByName, /* domainLookupByName */
+    NULL, /* domainSuspend */
+    NULL, /* domainResume */
+    NULL, /* domainShutdown */
+    NULL, /* domainReboot */
+    domainDestroy, /* domainDestroy */
+    NULL, /* domainGetOSType */
+    NULL, /* domainGetMaxMemory */
+    NULL, /* domainSetMaxMemory */
+    NULL, /* domainSetMemory */
+    domainGetInfo, /* domainGetInfo */
+    NULL, /* domainSave */
+    NULL, /* domainRestore */
+    NULL, /* domainCoreDump */
+    NULL, /* domainSetVcpus */
+    NULL, /* domainSetVcpusFlags */
+    NULL, /* domainGetVcpusFlags */
+    NULL, /* domainPinVcpu */
+    NULL, /* domainGetVcpus */
+    NULL, /* domainGetMaxVcpus */
+    NULL, /* domainGetSecurityLabel */
+    NULL, /* nodeGetSecurityModel */
+    NULL, /* domainDumpXML */
+    NULL, /* domainXMLFromNative */
+    NULL, /* domainXMLToNative */
+    listDefinedDomains, /* listDefinedDomains */
+    numOfDefinedDomains, /* numOfDefinedDomains */
+    domainCreate, /* domainCreate */
+    NULL, /* domainCreateWithFlags */
+    NULL, /* domainDefineXML */
+    NULL, /* domainUndefine */
+
+    NULL, /* domainAttachDevice */
+    NULL, /* domainAttachDeviceFlags */
+    NULL, /* domainDetachDevice */
+    NULL, /* domainDetachDeviceFlags */
+    NULL, /* domainUpdateDeviceFlags */
+    NULL, /* domainGetAutostart */
+    NULL, /* domainSetAutostart */
+    NULL, /* domainGetSchedulerType */
+    NULL, /* domainGetSchedulerParameters */
+    NULL, /* domainSetSchedulerParameters */
+    NULL, /* domainMigratePrepare */
+    NULL, /* domainMigratePerform */
+    NULL, /* domainMigrateFinish */
+    NULL, /* domainBlockStats */
+    NULL, /* domainInterfaceStats */
+    NULL, /* domainMemoryStats */
+    NULL, /* domainBlockPeek */
+    NULL, /* domainMemoryPeek */
+    NULL, /* domainGetBlockInfo */
+    NULL, /* nodeGetCellsFreeMemory */
+    NULL, /* getFreeMemory */
+    NULL, /* domainEventRegister */
+    NULL, /* domainEventDeregister */
+    NULL, /* domainMigratePrepare2 */
+    NULL, /* domainMigrateFinish2 */
+    NULL, /* nodeDeviceDettach */
+    NULL, /* nodeDeviceReAttach */
+    NULL, /* nodeDeviceReset */
+    NULL, /* domainMigratePrepareTunnel */
+    NULL, /* isEncrypted */
+    NULL, /* isEncrypted */
+    NULL, /* domainIsActive */
+    domainIsPersistent, /* domainIsPersistent */
+    NULL, /* domainIsUpdated */
+    NULL, /* cpuCompare */
+    NULL, /* cpuBaseline */
+    NULL, /* domainGetJobInfo */
+    NULL, /* domainAbortJob */
+    NULL, /* domainMigrateSetMaxDowntime */
+    domainEventRegisterAny, /* domainEventRegisterAny */
+    domainEventDeregisterAny, /* domainEventDeregisterAny */
+    NULL, /* domainManagedSave */
+    NULL, /* domainHasManagedSaveImage */
+    NULL, /* domainManagedSaveRemove */
+    NULL, /* domainSnapshotCreateXML */
+    NULL, /* domainSnapshotDumpXML */
+    NULL, /* domainSnapshotNum */
+    NULL, /* domainSnapshotListNames */
+    NULL, /* domainSnapshotLookupByName */
+    NULL, /* domainHasCurrentSnapshot */
+    NULL, /* domainSnapshotCurrent */
+    NULL, /* domainRevertToSnapshot */
+    NULL, /* domainSnapshotDelete */
+    NULL, /* qemuDomainMonitorCommand */
+    NULL, /* domainSetMemoryParameters */
+    NULL, /* domainGetMemoryParameters */
+    NULL, /* domainOpenConsole */
+};
+
+/**
+ * NOVA Register:
+ *
+ * Registers the NOVA driver
+ */
+int
+novaRegister(void)
+{
+    if (virRegisterDriver(&novaDriver) < 0) return -1;
+    return 0;
+}
diff -urN libvirt-0.8.8/src/nova/nova_driver.h libvirt-0.8.8-own/src/nova/nova_driver.h
--- libvirt-0.8.8/src/nova/nova_driver.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.8.8-own/src/nova/nova_driver.h	2011-05-26 10:21:26.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef __VIR_NOVA_INTERNAL_H__
+# define __VIR_NOVA_INTERNAL_H__
+
+# include "internal.h"
+
+int novaRegister(void);
+
+#endif /* __VIR_NOVA_INTERNAL_H__ */
diff -urN libvirt-0.8.8/src/nova/nova_types.h libvirt-0.8.8-own/src/nova/nova_types.h
--- libvirt-0.8.8/src/nova/nova_types.h	1970-01-01 01:00:00.000000000 +0100
+++ libvirt-0.8.8-own/src/nova/nova_types.h	2011-06-21 12:49:46.000000000 +0200
@@ -0,0 +1,33 @@
+enum LIBVIRT_NOVA_OPCODE {
+  NOVA_OP_FAILED   = 0x8,
+  NOVA_OP_SUCCEEDED = 0x9,
+  NOVA_PACKET_LEN  = 0x40,
+  NOVA_NUM_OF_ACTIVE_DOMAINS = 0x20,
+  NOVA_NUM_OF_DEFINED_DOMAINS,
+  NOVA_LIST_ACTIVE_DOMAINS,
+  NOVA_LIST_DEFINED_DOMAINS,
+  NOVA_GET_NAME_ID,
+  NOVA_GET_NAME_UUID,
+  NOVA_GET_NAME,
+  NOVA_GET_VM_INFO,
+  NOVA_VM_START,
+  NOVA_VM_DESTROY,
+  NOVA_UNSUPPORTED_VERSION,
+  NOVA_ENABLE_EVENT,
+  NOVA_DISABLE_EVENT,
+  NOVA_EVENT,
+  EVENT_REBOOT = 0xbbbb
+};
+
+struct incoming_packet {
+  uint16_t version;
+  uint16_t opcode;
+  unsigned char opspecific;
+} __attribute__((packed));
+
+struct outgoing_packet {
+  uint16_t version;
+  uint16_t opcode;
+  uint8_t  result;
+  unsigned char opspecific;
+} __attribute__((packed));
