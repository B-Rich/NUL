#!/usr/bin/perl -w
#
# @file 
# Script to supervise the execution of wvtest-based tests.
#
# It takes care of killing test (qemu or serial reader) when the test
# finishes or hangs.
#
# Copyright (C) 2011, Michal Sojka <sojka@os.inf.tu-dresden.de>
# Economic rights: Technische Universitaet Dresden (Germany)
#
# This file is part of NUL (NOVA user land).
#
# NUL is free software: you can redistribute it and/or
# modify it under the terms of the GNU General Public License version
# 2 as published by the Free Software Foundation.
#
# NUL is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License version 2 for more details.
#/

use strict;

# always flush
$| = 1;

my $pid = open(my $fh, "-|");
if (!$pid) {
    # child
    open STDERR, '>&STDOUT' or die("Can't dup stdout: $!\n");
#    setpgrp(); # Terminal won't send signals to the child
    exec(@ARGV);
    exit 126; # just in case
}

sub bigkill($)
{
    my $pid = shift;
    ($pid > 0) || die("pid is '$pid'?!\n");

    local $SIG{CHLD} = sub { }; # this will wake us from sleep() faster
    kill 15, $pid;
    sleep(2);

    if ($pid > 1) {
	kill 9, -$pid;
    }
    kill 9, $pid;

    exit(125);
}

my $timeout = 100;

# parent
local $SIG{INT} = sub { bigkill($pid); };
local $SIG{TERM} = sub { bigkill($pid); };
local $SIG{ALRM} = sub {
    print STDERR "! $0: Alarm timed out!  No test output for $timeout seconds.  FAILED\n";
    bigkill($pid);
};

my $allstart = time();
my ($start, $stop);
my $tests_executed = 0;
my $tests_failed = 0;
my $waits_for_child = 0;
my $kill_ok = 0;
alarm($timeout);
while (<$fh>)
{
    alarm($timeout);
    print;
    chomp;
    s/\r//g;

    if (/^(\([0-9]+\) (#   )?)?!\s*(.*?)\s+(\S+)\s*$/) {
	$tests_executed++;
	$tests_failed++ if ($4 ne "ok");
    }
    elsif (/wvtest: timeout (\d+)\s*$/) {
	$timeout=$1;
	if ($ENV{WVTEST_SKIP_LONG} && $timeout > 100) {
	    kill 15, $pid;		# Kill novaboot or qemu
	    exit 0;
	}
    }
    elsif (/sc: wait for child/) { $waits_for_child = 1; }
    elsif ((/sc: done.$/ && $waits_for_child) ||
	   /resetting machine via method/ ||
	   /wvtest: done\s*$/ ||
	   ( $ENV{WVTEST_EXIT_PATTERN} && /$ENV{WVTEST_EXIT_PATTERN}/ ) ||
	   / # .*System halted. *$/)
    {
	kill 15, $pid;		# Kill novaboot or qemu
	$kill_ok = 1;
    }
}
my $newpid = waitpid($pid, 0);
if ($newpid != $pid) {
    die("waitpid returned '$newpid', expected '$pid'\n");
}

my $code = $?;
my $ret = ($code >> 8);

if ($code && !$ret) {
    if ($kill_ok && $code == 15) {
	# We have killed the child - it is OK
	$code = 0;
    } else {
	# return death-from-signal exits as >128.  This is what bash does if you ran
	# the program directly.
	$ret = $code | 128;
    }
}

if ($ret != 0) {
    print "! $0: Program '", join(" ", @ARGV), "' returned non-zero exit code ($ret)  FAILED\n";
}

if (!$ENV{WVTEST_EXIT_PATTERN}) {
    printf "! $0: \$tests_executed > 0  %s\n", ($tests_executed > 0) ? "ok" : "FAILED";
}
if ($tests_failed > 0) { $ret = 1; }
if ($ret == 0 && $tests_executed == 0) { $ret = 1; }

exit $ret;
